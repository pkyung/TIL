## jvm 구조에 대해 이해하고 .java 소스를 어떻게 실행하는지 이해하기

### JVM이란 무엇인가

Java Virtual Machine 즉, 자바를 실행하기 위한 가상 기계 (소프트웨어로 구현된 하드웨어)

![image](../image/jvm.png)

일반 어플리케이션 코드는 os만 거치고 하드웨어로 전달되는데, java 어플리케이션은 jvm을 한 번 더 거친다. 이 과정에서 하드웨어에 맞게 완전히 컴파일된 상태가 아니라 실행 시에 interpret 되기 떄문에 속도가 느리다는 단점이 있다. 그러나 요즘엔 바이트코드를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도의 격차를 많이 줄였다.

jvm이 없을 경우 어플리케이션은 os와 바로 맞붙어 있기 떄문에 os에 종속적이게 된다. 그래서 다른 os에 실행시키기 위해서는 어플리케이션을 그 os에 맞게 변경해야 한다. 그러나 jvm을 사용하는 java 어플리케이션은 jvm하고 상호작용 하기 때문에 os가 달라지더라도 프로그램 변경 없이 실행 가능하는 장점이 있다.

### 컴파일 방법

1. 개발자가 자바 소스코드를 작성함
2. 자바 컴파일러가 .java 파일을 읽어 바이트코드 (.class)로 컴파일함 - 바이트코드 : 컴퓨터는 읽을 수 없고 jvm이 읽을 수 있는 코드
3. 컴파일된 바이트코드를 jvm의 클래스 로더에게 전달함
4. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM 메모리에 올림 - 동적 로딩 : 필요한 클래스를 필요할 때마다 로드하는 방식
5. execution engine 은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행함

   - 인터프리터 : 바이트코드 명령어를 하나씩 읽어서 해석
   - JIT(Just-In-Time) 컴파일러 : 바이트코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고 바이너리 코드로 직접 실행하는 방식

```vim
javac Test.java
java Test
```

### JVM 구성 요소

![image](../image/structure.png)

#### 클래스 로더

자바는 런타임에 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 특징이 있다. (동적 로딩) 이것을 담당하는 부분이 JVM의 클래스 로더이다.

#### 메모리

메모리 영역은 프로그램을 실행하기 위해 os에서 할당 받은 메모리 공간이다.

- 메서드 영역 : 클래스 정보, 메서드 정보, 상수 등 저장
- 힙 영역 : new 키워드로 생성된 객체와 배열이 생성되는 영역, 메서드 영역에 로드된 클래스만 생성 가능하고 garbage collector가 참조되지 않는 메모리를 확인/제거하는 영역
- 스택 영역 : 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역으로 클래스 수준의 정보 저장
- pc 레지스터 : 현재 실행 중인 JVM 명령어의 주소를 저장
- 네이티브 메서드 스택 : 자바 외 언어로 작성된 네이티브 코드를 실행하기 위한 메모리 영역

#### 실행 엔진

로딩된 클래스 파일의 바이트코드를 해석하고 실행한다. 여기에 인터프리터와 JIT 컴파일어를 포함한다.

#### 가비지 컬렉터 (Garbage Collector)

가비지 컬렉터는 힙 영역에서 사용되지 않는 객체를 자동으로 검출하고 메모리를 회수하는 역할을 한다. 실행 엔진에 포함된다.

#### JNI (Java Native Interface)

JNI는 자바 어플리케이션에서 C, C++ 등 다른 언어로 작성된 코드를 실행할 수 있게 해주는 인터페이스이다. 네이티브 메서드 라이브러리는 이러한 외부 코드와의 연결을 가능하게 하는 구현체이다.

## 오늘의 질문

jvm 이 이진코드로 프로그램을 로드한다면 바이트 코드 변환을 건너뛸 수 있지 않나?

gpt say -> 자바에서 바이트코드라는 중간 표현을 사용하는 것은 자바의 철학과 실행 모델에서 중요한 역할을 한다.

1. 플랫폼 독립성 보장
   - 만약 jvm이 처음부터 이진 코드로 프로그램을 로드한다면, 이진 코드는 운영체제에 의존적일 수 밖에 없다. 즉, 하나의 프로그램이 여러 플랫폼에 실행되려면 각 플랫폼에 맞는 별도의 이진 코드를 생성해야 한다. 하지만 바이트코드를 사용하면, JVM이 플랫폼에 맞는 이진 코드로 변환해 실행할 수 있으므로 플랫폼 독립성을 유지할 수 있다.
2. 동적 로딩과 실행 유연성
   - 자바의 바이트코드는 런타임에 클래스를 동적으로 로딩할 수 있는 유연성을 제공한다. 바이트코드 수준에서 최적화를 수행하거나, 필요 시점에만 특정 클래스나 메서드를 실행하기 때문에 메모리 사용과 성능 면에서 효율적이다.
3. 보안 및 관리 용이성
   - 바이트코드는 JVM 내에서 실행되므로, JVM이 이를 검증하고 제어할 수 있다.
   - Bytecode Verifier는 바이트코드가 JVM 규칙을 따르는지 확인하고, 메모리 침범이나 보안 위협을 방지한다.
4. 다중 언어 지원
   - JVM은 자바만 실행하는 것이 아니라 Kotlin, Scala, Groovy 와 같은 다른 언어들도 지원한다. 이러한 언어들은 각각의 소스 코드를 바이트코드로 변환하여 JVM에서 실행되므로, 다양한 언어를 공통된 플랫폼에서 실행할 수 있다.
